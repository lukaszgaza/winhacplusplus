using namespace std;

#ifndef __BeamHandler_h__
#define __BeamHandler_h__

#include <cstdlib>
#include <vector>
#include "ProcessHandler.h"
#include "../../utils/FOAM/TRND.h"
#include "../pdf/PDF.h"

class TFOAM;

namespace VINHAC {
class DataSource;
class Manager;
class Event;
class BeamParticle;
class ppWintegrand;
class Reader;
class PDF_LHA;
class PDF_Simple;
class ProcessHandler;
class BeamHandler;
}

namespace VINHAC {

//!  Class resposible for hadron level process handling.
/*!
  This class generates two quarks using PDFs and fills properties in Event class.
  If hadron level is off then it realy do nothing special, only fills event.
  For quarks generation it can be used LHAPDF, PDF_Simple (a simple parametrization).
  It internally uses FOAM integrator to handle PDFs.
*/

class BeamHandler: public ProcessHandler {

private:

	Manager* p_Manager; //!< pointer to manager

	////////////////////////////BEAM PARAMETERS///////////////////////////////////////////////////
	double Ecm; //!< CMS energy of incoming hadron beams 14e3 Ecm for LHC sum of two beams
	double s; //!< Mandelstam variable

	////////////////////////////PARTICLES/////////////////////////////////////////////////////////
	////Beam particle
	BeamParticle* p_beamParticleA; //!< Beam particle A
	BeamParticle* p_beamParticleB; //!< Beam particle B
	//PDF settings
	double x_max; //!< Max value of x for PDF
	double x_min; //!< Min value of x for PDF
	string pdfNameA;//!< Name of PDF for particle A
	string pdfNameB;//!< Name of PDF for particle B
	int pdfSubsetA;//!< Subset of PDF for particle A
	int pdfSubsetB;//!< Subset of PDF for particle B
	int pdflibNGroupA;
	int pdflibNGroupB;
	int pdflibNSetA;
	int pdflibNSetB;
	int pdfIdA;
	int pdfIdB;

	//Partons
	double x1_parton;//!< Bjorken x of parton 1
	double x2_parton;//!< Bjorken x of parton 2

	////Foam
	TRND *p_randomGenerator;//!< Pointer to uniform random number generator

	TFOAM* p_FoamX;//!< Pointer to FOAM integrator
	double wtEvent;//!< Variable to store event's weight
	////CrudXSection
	double normalizationFactor;//!< normalization factor for crud cross section
	double wtFoam;//!< variable to store foam weight
	double XsCrud;//!< crude cross section
	double XsCrudError;//!< error of crud cross section
	double XsCrudWt;//!< variable used to treat crude cross section as weight

	ppWintegrand *integrand;//!< pointer to integrand used by FOAM

	PDF* pdfObject;
	vector<double> xPDFa; //!< storage of xs generated by FOAM
	vector<double> xPDFb;//!< storage of xs generated by FOAM
	double scalePDF;

	vector<int> dQuarks; //!< storage of down quarks PDG ids set in input file
	vector<int> dAntiQuarks; //!< storage of down antiquarks PDG ids set in input file
	vector<int> uQuarks;//!< storage of up quarks PDG ids set in input file
	vector<int> uAntiQuarks;//!< storage of up antiquarks PDG ids set in input file

	bool isWplus;//!< flag stores if W+ is present in input file
	bool isWminus;//!< flag stores if W- is present in input file

	struct compClass {
		//!  Comparator used to order quarks by PDGid
		/*!
		  It compares absolute values of PDGid
		*/
		bool operator()(int i, int j) {
			return abs(i) < abs(j);
		}
	} comparator;//!< comparator used to order quarks


	//////////////////////////////////////////////////////////////////////////////////////////////
	//                                     METHODS                                              //
	//////////////////////////////////////////////////////////////////////////////////////////////


	/**
	* method which generates quarks flavours
	* @param event reference to current evolved event
	*/
	void generateFlavours(Event& event);


	/**
	* method which initializes integrand for FOAM
	*/
	bool initializeIntegrand();

	/**
	* method which initializes FOAM
	*/
	bool initializeFOAM();


	/**
	* method which sets normalization factor of crude cross section
	*/
	void setNormalizationFactor();


	/**
	* method which generates Bjorken's xs of quarks
	* @param event reference to current evolved event
	*/
	double generateQuarks(Event& event);

	/**
	* method which produces quarks kinematics using generated xs
	* @param event reference to current evolved event
	*/
	double setPartonsKinematics(Event& event);

	/**
	* method which cleans data
	*/
	void cleanBeamHandlerData();

	/**
	* method which sets crude cross section in the handler
	*/
	void setXsCrud();

	friend class LHEWriter;
public:

	/**
	* \brief Method which calculates crude cross section for parton level process.
	*
	* It is used internally by ppWintegrand to calculate hadron level crude or just for calculate crude
	* when hadron level is off.
	* @see ppWintegrand
	* @param Uij CKM matrix element
	* @param s Mandelstam's variable for incomming quarks
	* @return parton level crude cross section
	*/
	double totalXsCrude(const double& Uij,const double& s);

	/**
	* \brief Constructor of BeamHandler
	*
	* It requires DataSource object with input data and pointer to TRND random number generator.
	* It does the initialization of BeamHandler.
	* @see DataSource
	* @see TRND
	* @param ds pointer to structure with input data
	* @param p_randomGenerator pointer to random number generator
	*/
	BeamHandler(TRND *p_randomGenerator);

	/**
	* \brief Destructor of BeamHandler
	*
	* It takes care of memory release
	*/
	~BeamHandler();

	/**
	* \brief returns crude cross section
	*
	* @return crude cross section
	*/
	inline double getXsCrud() const{
		return XsCrud;
	}

	/**
	* \brief returns crude cross section error
	*
	* @return crude cross section error
	*/
	inline double getXsCrudError() const {
		return XsCrudError;
	}

	/**
	* \brief evolves the event
	*
	* It does whole part of generation process which is to do in this handler
	* @see Event
	* @param event reference to current Event object
	* @return if weight was zero
	*/
	bool eventEvolve(VINHAC::Event& event);


	/**
	* \brief returns PDF's name set in beam A
	*
	* @return PDF's name set in beam A
	*/
	inline const string& getPdfNameA() const{
		return pdfNameA;
	}

	/**
	* \brief returns PDF's name set in beam B
	*
	* @return PDF's name set in beam B
	*/
	inline const string& getPdfNameB() const{
		return pdfNameB;
	}

	/**
	* \brief sets pointer to random number generator
	*
	* @see TRND
	* @param p_Generator pointer to random number generator
	*/
	inline void setRandomNumberGenerator(TRND *p_Generator) {
		p_randomGenerator = p_Generator;
	}

	/**
	* \brief sets Bjorken's xs for beam A
	*
	* It is used internally by ppWintegrand
	* @see ppWintegrand
	* @param xpdf vector of xs for beam A
	*/
	inline void setXPDFa(const vector<double>& xpdf) {
		xPDFa = xpdf;
	}

	/**
	* \brief sets Bjorken's xs for beam B
	*
	* It is used internally by ppWintegrand
	* @see ppWintegrand
	* @param xpdf vector of xs for beam B
	*/
	inline void setXPDFb(const vector<double>& xpdf) {
		xPDFb = xpdf;
	}

	/**
	* \brief sets pdf scale
	*
	* It is used internally by ppWintegrand
	* @see ppWintegrand
	* @param scalePDF pdf scale
	*/
	inline void setScalePDF(const double& scalePDF) {
		this->scalePDF = scalePDF;
	}

};

}

#endif
